<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Animation Creator</title>
  <!-- Manifest for PWA install -->
  <link rel="manifest" href="manifest.json">
  <style>
    /* ===== Responsive, sleek styling ===== */
    body {
      background: #f0f2f5;
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 5px;
    }
    #toolbar {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      padding: 8px;
      margin-bottom: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
      width: 100%;
      max-width: 800px;
    }
    .tool-group {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }
    button {
      background: #007bff;
      color: #fff;
      border: none;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 14px;
      flex: 1 1 auto;
      min-width: 60px;
      text-align: center;
    }
    button:hover { background: #0056b3; }
    button.active { background: #0056b3; }
    input[type="color"], input[type="number"] {
      padding: 4px;
      border-radius: 4px;
      border: 1px solid #ccc;
      font-size: 14px;
    }
    label { font-size: 14px; color: #333; }
    #main {
      width: 100%;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #canvas {
      border: 2px solid #ccc;
      border-radius: 8px;
      background: #fff;
      width: 100%;
      height: auto;
      touch-action: none;
    }
    #framesPanel {
      margin-top: 8px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      justify-content: center;
    }
    #framesPanel img {
      width: 60px;
      border: 2px solid transparent;
      border-radius: 4px;
      cursor: pointer;
    }
    #framesPanel img.active-frame {
      border-color: #007bff;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="tool-group">
      <button id="penTool" class="active">Pen</button>
      <button id="eraserTool">Eraser</button>
      <button id="bucketTool">Bucket</button>
      <button id="selectTool">Select</button>
      <button id="copySelection">Copy</button>
      <button id="pasteTool">Paste</button>
      <button id="undoBtn">Undo</button>
    </div>
    <div class="tool-group">
      <input type="color" id="colorPicker" value="#000000">
      <button id="importImageBtn">Import</button>
      <input type="file" id="importImage" accept="image/*" style="display:none">
    </div>
    <div class="tool-group">
      <button id="addFrame">Add Frame</button>
      <button id="deleteFrame">Delete Frame</button>
      <label for="frameRateInput">FPS:</label>
      <input type="number" id="frameRateInput" min="1" max="60" value="30">
      <button id="previewAnim">Preview</button>
      <button id="downloadMP4">Export</button>
    </div>
    <div class="tool-group">
      <label for="bgColorPicker">Bg:</label>
      <input type="color" id="bgColorPicker" value="#ffffff">
      <button id="uploadBgBtn">Bg Img</button>
      <input type="file" id="uploadBg" accept="image/*" style="display:none">
    </div>
    <div class="tool-group">
      <button id="saveProject">Save</button>
      <button id="loadProject">Load</button>
      <input type="file" id="loadProjectInput" accept=".json" style="display:none">
    </div>
  </div>

  <div id="main">
    <canvas id="canvas" width="800" height="500"></canvas>
    <div id="framesPanel"></div>
  </div>

  <script>
  // ======== Service Worker Registration ========
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('service-worker.js');
  }

  // ======== Element refs ========
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const penTool = document.getElementById('penTool'),
        eraserTool = document.getElementById('eraserTool'),
        bucketTool = document.getElementById('bucketTool'),
        selectTool = document.getElementById('selectTool'),
        copyBtn = document.getElementById('copySelection'),
        pasteTool = document.getElementById('pasteTool'),
        undoBtn = document.getElementById('undoBtn'),
        colorPicker = document.getElementById('colorPicker'),
        importBtn = document.getElementById('importImageBtn'),
        importInput = document.getElementById('importImage'),
        addFrameBtn = document.getElementById('addFrame'),
        deleteFrameBtn = document.getElementById('deleteFrame'),
        previewBtn = document.getElementById('previewAnim'),
        exportBtn = document.getElementById('downloadMP4'),
        frameRateInput = document.getElementById('frameRateInput'),
        bgColorPicker = document.getElementById('bgColorPicker'),
        uploadBgBtn = document.getElementById('uploadBgBtn'),
        uploadBgInput = document.getElementById('uploadBg'),
        saveBtn = document.getElementById('saveProject'),
        loadBtn = document.getElementById('loadProject'),
        loadInput = document.getElementById('loadProjectInput'),
        framesPanel = document.getElementById('framesPanel');

  // ======== State & offscreen layers ========
  let currentTool='pen', drawing=false, lastX=0, lastY=0;
  let frames=[], currentFrameIndex=-1, lastFrameData=null;
  let background={color:'#ffffff',image:null};
  const offscreen = document.createElement('canvas');
  offscreen.width=canvas.width; offscreen.height=canvas.height;
  const octx=offscreen.getContext('2d');
  const undoStack=[];

  // ======== Utility: map touch/mouse to canvas coords ========
  function getPos(e){
    const rect=canvas.getBoundingClientRect();
    // handle mouse or touch
    const x=((e.touches?e.touches[0].clientX:e.clientX)-rect.left)*(canvas.width/rect.width);
    const y=((e.touches?e.touches[0].clientY:e.clientY)-rect.top)*(canvas.height/rect.height);
    return {x,y};
  }

  function pushUndo(){
    undoStack.push(octx.getImageData(0,0,canvas.width,canvas.height));
    if(undoStack.length>50) undoStack.shift();
  }
  function undo(){
    if(!undoStack.length) return;
    const img=undoStack.pop();
    octx.putImageData(img,0,0);
    redraw();
  }

  // ======== Redraw main canvas ========
  function redraw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    // background
    if(background.image){
      const img=new Image();
      img.onload=()=>{ctx.drawImage(img,0,0,canvas.width,canvas.height);drawOverlay()};
      img.src=background.image;
    } else {
      ctx.fillStyle=background.color;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      drawOverlay();
    }
    function drawOverlay(){
      if(lastFrameData){
        ctx.globalAlpha=0.3;
        const s=new Image();
        s.onload=()=>{
          ctx.drawImage(s,0,0,canvas.width,canvas.height);
          ctx.globalAlpha=1;
          ctx.drawImage(offscreen,0,0);
        };
        s.src=lastFrameData;
      } else {
        ctx.drawImage(offscreen,0,0);
      }
    }
  }

  // ======== Tool button state ========
  function updateTools(){
    [penTool,eraserTool,bucketTool,selectTool,pasteTool].forEach(b=>b.classList.remove('active'));
    ({pen:penTool,eraser:eraserTool,bucket:bucketTool,select:selectTool,paste:pasteTool}[currentTool]).classList.add('active');
  }

  [penTool,eraserTool,bucketTool,selectTool,pasteTool].forEach(btn=>{
    btn.onclick=()=>{currentTool=btn.id.replace('Tool','');updateTools()};
  });
  undoBtn.onclick=undo;
  colorPicker.onchange=()=>{/* strokeStyle read on draw */};

  // ======== Drawing ========
  function startDraw(e){
    if(currentTool!=='pen'&&currentTool!=='eraser')return;
    pushUndo();
    drawing=true;
    const p=getPos(e); lastX=p.x; lastY=p.y;
    if(currentTool==='eraser'){octx.save();octx.globalCompositeOperation='destination-out';octx.lineWidth=10}
    else{octx.restore();octx.globalCompositeOperation='source-over';octx.lineWidth=3;octx.strokeStyle=colorPicker.value;}
  }
  function doDraw(e){
    if(!drawing) return;
    const p=getPos(e);
    octx.beginPath();octx.moveTo(lastX,lastY);octx.lineTo(p.x,p.y);octx.stroke();
    lastX=p.x; lastY=p.y; redraw();
  }
  function endDraw(){ if(currentTool==='eraser')octx.restore();drawing=false }

  // ======== Bucket Fill ========
  function flood(x,y,color){
    pushUndo();
    const img=octx.getImageData(0,0,canvas.width,canvas.height), data=img.data;
    const w=canvas.width,h=canvas.height;
    const hex=color.slice(1),rF=parseInt(hex.substr(0,2),16),gF=parseInt(hex.substr(2,2),16),
          bF=parseInt(hex.substr(4,2),16),aF=255;
    const stack=[[Math.floor(x),Math.floor(y)]];
    const idx=(y*w+x)*4, rT=data[idx],gT=data[idx+1],bT=data[idx+2],aT=data[idx+3];
    if(rT===rF&&gT===gF&&bT===bF&&aT===aF) return;
    function match(i){return data[i]===rT&&data[i+1]===gT&&data[i+2]===bT&&data[i+3]===aT;}
    while(stack.length){
      const [cx,cy]=stack.pop();
      let py=cy,pi=(py*w+cx)*4;
      while(py>=0&&match(pi)){py--;pi-=w*4}
      py++;pi+=w*4;
      let reachL=false,reachR=false;
      while(py<h&&match(pi)){
        data[pi]=rF;data[pi+1]=gF;data[pi+2]=bF;data[pi+3]=aF;
        if(cx>0){
          if(match(pi-4)){if(!reachL){stack.push([cx-1,py]);reachL=true}}
          else reachL=false;
        }
        if(cx<w-1){
          if(match(pi+4)){if(!reachR){stack.push([cx+1,py]);reachR=true}}
          else reachR=false;
        }
        py++;pi+=w*4;
      }
    }
    octx.putImageData(img,0,0);
    redraw();
  }

  // ======== Selection & Move ========
  let isSelecting=false,isSelectionActive=false,selectionStart=null,selectionRect=null,
      savedSelection=null,isMoving=false,moveOffset=null,movePos=null,clipboard=null;
  function selStart(p){
    if(isSelectionActive&&p.x>=selectionRect.x&&p.x<=selectionRect.x+selectionRect.w
      &&p.y>=selectionRect.y&&p.y<=selectionRect.y+selectionRect.h){
      isMoving=true;
      moveOffset={x:p.x-selectionRect.x,y:p.y-selectionRect.y};
      movePos={x:selectionRect.x,y:selectionRect.y};
    } else {
      isSelecting=true; selectionStart=p;
      selectionRect={x:p.x,y:p.y,w:0,h:0};
      savedImage=octx.getImageData(0,0,canvas.width,canvas.height);
      isSelectionActive=false;
    }
  }
  function selMove(p){
    if(isSelecting){
      selectionRect.x=Math.min(selectionStart.x,p.x);
      selectionRect.y=Math.min(selectionStart.y,p.y);
      selectionRect.w=Math.abs(p.x-selectionStart.x);
      selectionRect.h=Math.abs(p.y-selectionStart.y);
      redraw();
      ctx.save();ctx.setLineDash([5,3]);ctx.strokeStyle='red';
      ctx.strokeRect(selectionRect.x,selectionRect.y,selectionRect.w,selectionRect.h);
      ctx.restore();
    } else if(isMoving){
      movePos={x:p.x-moveOffset.x,y:p.y-moveOffset.y};
      redraw();
      ctx.putImageData(savedSelection,movePos.x,movePos.y);
      ctx.save();ctx.setLineDash([5,3]);ctx.strokeStyle='red';
      ctx.strokeRect(movePos.x,movePos.y,selectionRect.w,selectionRect.h);
      ctx.restore();
    }
  }
  function selEnd(){
    if(isSelecting){
      isSelecting=false;
      if(selectionRect.w>0&&selectionRect.h>0){
        savedSelection=octx.getImageData(selectionRect.x,selectionRect.y,selectionRect.w,selectionRect.h);
        isSelectionActive=true;
      }
      redraw();
      ctx.save();ctx.setLineDash([5,3]);ctx.strokeStyle='red';
      ctx.strokeRect(selectionRect.x,selectionRect.y,selectionRect.w,selectionRect.h);
      ctx.restore();
    } else if(isMoving){
      pushUndo();
      octx.clearRect(selectionRect.x,selectionRect.y,selectionRect.w,selectionRect.h);
      octx.putImageData(savedSelection,movePos.x,movePos.y);
      selectionRect.x=movePos.x;selectionRect.y=movePos.y;
      isMoving=false;isSelectionActive=false;
      redraw();
    }
  }
  copyBtn.onclick=()=>{
    if(isSelectionActive) clipboard=savedSelection;
    else alert('No selection');
  };
  function pasteAt(p){
    if(!clipboard) return alert('No clipboard');
    pushUndo();
    octx.putImageData(clipboard,p.x,p.y);
    redraw();
    currentTool='pen';updateTools();
  }

  // ======== Import Image ========
  importBtn.onclick=()=>importInput.click();
  importInput.onchange=e=>{
    const f=e.target.files[0]; if(!f)return;
    const r=new FileReader();
    r.onload=ev=>{
      const img=new Image();
      img.onload=()=>{
        pushUndo();octx.drawImage(img,0,0,canvas.width,canvas.height);
        redraw();
      };
      img.src=ev.target.result;
    };
    r.readAsDataURL(f);
  };

  // ======== Frame Management ========
  addFrameBtn.onclick=()=>{
    const tmp=document.createElement('canvas');
    tmp.width=canvas.width; tmp.height=canvas.height;
    const tctx=tmp.getContext('2d');
    if(background.image){
      const b=new Image();
      b.onload=()=>{
        tctx.drawImage(b,0,0,canvas.width,canvas.height);
        tctx.drawImage(offscreen,0,0);
        saveFrame();
      };
      b.src=background.image;
    } else {
      tctx.fillStyle=background.color;
      tctx.fillRect(0,0,canvas.width,canvas.height);
      tctx.drawImage(offscreen,0,0);
      saveFrame();
    }
    function saveFrame(){
      const data=tmp.toDataURL();
      frames.push(data);
      currentFrameIndex=frames.length-1;
      lastFrameData=data;
      updatePanel();
      octx.clearRect(0,0,canvas.width,canvas.height);
      undoStack.length=0;
      redraw();
    }
  };
  deleteFrameBtn.onclick=()=>{
    if(currentFrameIndex<0) return alert('No frame');
    frames.splice(currentFrameIndex,1);
    if(!frames.length){
      currentFrameIndex=-1;lastFrameData=null;
      octx.clearRect(0,0,canvas.width,canvas.height); redraw();
    } else {
      currentFrameIndex=Math.max(0,currentFrameIndex-1);
      loadFrame(currentFrameIndex);
    }
    updatePanel();
  };
  function updatePanel(){
    framesPanel.innerHTML='';
    frames.forEach((f,i)=>{
      const img=new Image();img.src=f;
      if(i===currentFrameIndex) img.classList.add('active-frame');
      img.onclick=()=>{loadFrame(i);updatePanel()};
      framesPanel.appendChild(img);
    });
  }
  function loadFrame(i){
    currentFrameIndex=i;
    const img=new Image();
    img.onload=()=>{
      octx.clearRect(0,0,canvas.width,canvas.height);
      octx.drawImage(img,0,0,canvas.width,canvas.height);
      redraw();lastFrameData=frames[i];undoStack.length=0;
    };
    img.src=frames[i];
  }

  // ======== Preview ========
  previewBtn.onclick=()=>{
    if(!frames.length) return alert('No frames');
    let i=0;
    clearInterval(previewInterval);
    previewInterval=setInterval(()=>{
      const img=new Image();
      img.onload=()=>{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        if(background.image){
          const b=new Image();
          b.onload=()=>{
            ctx.drawImage(b,0,0,canvas.width,canvas.height);
            ctx.drawImage(img,0,0,canvas.width,canvas.height);
          };
          b.src=background.image;
        } else {
          ctx.fillStyle=background.color;
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.drawImage(img,0,0,canvas.width,canvas.height);
        }
      };
      img.src=frames[i];
      i=(i+1)%frames.length;
    },1000/parseInt(frameRateInput.value));
    setTimeout(()=>{
      clearInterval(previewInterval);
      if(currentFrameIndex>=0) loadFrame(currentFrameIndex);
    },5000);
  };

  // ======== Export MP4 ========
  exportBtn.onclick=()=>{
    if(!frames.length) return alert('No frames');
    const fps=parseInt(frameRateInput.value)||30;
    const stream=canvas.captureStream(fps);
    let opts={mimeType:'video/mp4'};
    if(!MediaRecorder.isTypeSupported(opts.mimeType)){
      if(MediaRecorder.isTypeSupported('video/webm;codecs=vp9'))
        opts.mimeType='video/webm;codecs=vp9';
      else if(MediaRecorder.isTypeSupported('video/webm;codecs=vp8'))
        opts.mimeType='video/webm;codecs=vp8';
      else return alert('No recording support');
    }
    const rec=new MediaRecorder(stream,opts),chunks=[];
    rec.ondataavailable=e=>chunks.push(e.data);
    rec.onstop=()=>{
      const blob=new Blob(chunks,{type:opts.mimeType});
      const url=URL.createObjectURL(blob);
      const a=document.createElement('a');
      a.href=url; a.download='anim.mp4';
      document.body.appendChild(a);a.click();
      document.body.removeChild(a);URL.revokeObjectURL(url);
    };
    rec.start();
    let i=0,delay=1000/fps;
    (function play(){
      if(i>=frames.length){rec.stop();return}
      const img=new Image();
      img.onload=()=>{
        ctx.clearRect(0,0,canvas.width,canvas.height);
        if(background.image){
          const b=new Image();
          b.onload=()=>{
            ctx.drawImage(b,0,0,canvas.width,canvas.height);
            ctx.drawImage(img,0,0,canvas.width,canvas.height);
          };
          b.src=background.image;
        } else {
          ctx.fillStyle=background.color;
          ctx.fillRect(0,0,canvas.width,canvas.height);
          ctx.drawImage(img,0,0,canvas.width,canvas.height);
        }
        setTimeout(()=>{i++;play()},delay);
      };
      img.src=frames[i];
    })();
  };

  // ======== Background ========
  bgColorPicker.onchange=()=>{background.color=bgColorPicker.value;redraw()};
  uploadBgBtn.onclick=()=>uploadBgInput.click();
  uploadBgInput.onchange=e=>{
    const f=e.target.files[0];if(!f)return;
    const r=new FileReader();
    r.onload=ev=>{background.image=ev.target.result;redraw()};
    r.readAsDataURL(f);
  };

  // ======== Save / Load Project ========
  saveBtn.onclick=()=>{
    const proj=JSON.stringify({frames,currentFrameIndex,background});
    const a=document.createElement('a');
    a.href='data:text/json,'+encodeURIComponent(proj);
    a.download='project.json';document.body.appendChild(a);
    a.click();document.body.removeChild(a);
  };
  loadBtn.onclick=()=>loadInput.click();
  loadInput.onchange=e=>{
    const f=e.target.files[0];if(!f)return;
    const r=new FileReader();
    r.onload=ev=>{
      const p=JSON.parse(ev.target.result);
      frames=p.frames||[];currentFrameIndex=p.currentFrameIndex||-1;
      background=p.background||{color:'#ffffff',image:null};
      bgColorPicker.value=background.color;
      updatePanel();
      if(currentFrameIndex>=0) loadFrame(currentFrameIndex);
      else{octx.clearRect(0,0,canvas.width,canvas.height);redraw()}
    };
    r.readAsText(f);
  };

  // ======== Event binding ========
  canvas.addEventListener('mousedown',e=>{const p=getPos(e);if(currentTool==='select')selStart(p);else startDraw(e)});
  canvas.addEventListener('mousemove',e=>{const p=getPos(e);if(currentTool==='select')selMove(p);else doDraw(e)});
  canvas.addEventListener('mouseup',e=>{if(currentTool==='select')selEnd();else endDraw()});
  canvas.addEventListener('touchstart',e=>{const p=getPos(e);if(currentTool==='select')selStart(p);else startDraw(e)});
  canvas.addEventListener('touchmove',e=>{const p=getPos(e);if(currentTool==='select')selMove(p);else doDraw(e)});
  canvas.addEventListener('touchend',e=>{if(currentTool==='select')selEnd();else endDraw()});

  // ======== Initial ========
  octx.clearRect(0,0,canvas.width,canvas.height);
  redraw();
  </script>
</body>
</html>









