<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Animation Creator</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      font-family: Arial, sans-serif;
      background: #f4f7fa;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    #toolbar {
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    #toolbar button, #toolbar input[type="color"] {
      padding: 10px;
      font-size: 14px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #007bff;
      color: #fff;
      transition: background 0.2s;
    }
    #toolbar button:hover, #toolbar input[type="color"]:hover {
      background: #0056b3;
    }
    #toolbar button.active {
      background: #0056b3;
    }
    #main {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 800px;
    }
    canvas {
      border: 1px solid #ccc;
      background: #fff;
      touch-action: none;
      width: 100%;
      max-width: 800px;
      height: auto;
    }
    #framesPanel {
      margin-top: 10px;
      display: flex;
      gap: 5px;
      flex-wrap: wrap;
      justify-content: center;
    }
    #framesPanel img {
      width: 80px;
      height: auto;
      border: 2px solid transparent;
      cursor: pointer;
    }
    #framesPanel img.active-frame {
      border-color: #007bff;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <button id="penTool" class="active">Pen</button>
    <button id="bucketTool">Bucket</button>
    <input type="color" id="colorPicker" value="#000000">
    <button id="addFrame">Add Frame</button>
    <button id="previewAnim">Preview Animation</button>
    <button id="downloadMP4">Download MP4</button>
  </div>
  <div id="main">
    <canvas id="canvas" width="800" height="500"></canvas>
    <div id="framesPanel"></div>
  </div>
  <script>
    // Get elements and set up context
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const penToolBtn = document.getElementById('penTool');
    const bucketToolBtn = document.getElementById('bucketTool');
    const colorPicker = document.getElementById('colorPicker');
    const addFrameBtn = document.getElementById('addFrame');
    const previewAnimBtn = document.getElementById('previewAnim');
    const downloadMP4Btn = document.getElementById('downloadMP4');
    const framesPanel = document.getElementById('framesPanel');

    // App state
    let currentTool = 'pen';
    let drawing = false;
    let lastX = 0, lastY = 0;
    let frames = []; // Each frame is stored as a dataURL
    let currentFrameIndex = -1;
    let previewInterval = null;

    // Set up canvas default settings
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.strokeStyle = colorPicker.value;

    // Update active tool appearance
    function updateToolButtons() {
      penToolBtn.classList.toggle('active', currentTool === 'pen');
      bucketToolBtn.classList.toggle('active', currentTool === 'bucket');
    }

    // Event listeners for tool buttons
    penToolBtn.addEventListener('click', () => {
      currentTool = 'pen';
      updateToolButtons();
    });
    bucketToolBtn.addEventListener('click', () => {
      currentTool = 'bucket';
      updateToolButtons();
    });
    colorPicker.addEventListener('change', () => {
      ctx.strokeStyle = colorPicker.value;
    });

    // Pen drawing functions
    function startDrawing(e) {
      if (currentTool !== 'pen') return;
      drawing = true;
      const pos = getPos(e);
      lastX = pos.x;
      lastY = pos.y;
    }
    function draw(e) {
      if (!drawing || currentTool !== 'pen') return;
      const pos = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      lastX = pos.x;
      lastY = pos.y;
    }
    function stopDrawing() {
      drawing = false;
    }

    // Get mouse / touch position relative to the canvas
    function getPos(e) {
      let rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      return { x, y };
    }

    // Flood fill algorithm for the bucket tool
    function floodFill(startX, startY, fillColor) {
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      const width = canvas.width;
      const height = canvas.height;
      
      // Convert fill color hex to rgba
      const hex = fillColor.replace('#', '');
      const rFill = parseInt(hex.substring(0,2), 16);
      const gFill = parseInt(hex.substring(2,4), 16);
      const bFill = parseInt(hex.substring(4,6), 16);
      const aFill = 255;
      
      const pixelStack = [[startX, startY]];
      const offset = (startY * width + startX) * 4;
      const rTarget = data[offset];
      const gTarget = data[offset+1];
      const bTarget = data[offset+2];
      const aTarget = data[offset+3];

      // If the target color and fill color are the same, nothing to do.
      if (rTarget === rFill && gTarget === gFill && bTarget === bFill && aTarget === aFill) {
        return;
      }

      while(pixelStack.length) {
        const newPos = pixelStack.pop();
        const x = newPos[0];
        let y = newPos[1];
        let pixelPos = (y * width + x) * 4;
        // move up as long as the color matches and weâ€™re inside the canvas
        while(y >= 0 && matchColor(pixelPos, rTarget, gTarget, bTarget, aTarget, data)) {
          y--;
          pixelPos -= width * 4;
        }
        y++;
        pixelPos += width * 4;
        let reachLeft = false;
        let reachRight = false;
        while (y < height && matchColor(pixelPos, rTarget, gTarget, bTarget, aTarget, data)) {
          // fill the current pixel with the fill color
          data[pixelPos] = rFill;
          data[pixelPos+1] = gFill;
          data[pixelPos+2] = bFill;
          data[pixelPos+3] = aFill;
          
          // check left pixel
          if (x > 0) {
            if(matchColor(pixelPos - 4, rTarget, gTarget, bTarget, aTarget, data)) {
              if(!reachLeft){
                pixelStack.push([x - 1, y]);
                reachLeft = true;
              }
            } else if(reachLeft) {
              reachLeft = false;
            }
          }
          // check right pixel
          if (x < width - 1) {
            if(matchColor(pixelPos + 4, rTarget, gTarget, bTarget, aTarget, data)) {
              if(!reachRight){
                pixelStack.push([x + 1, y]);
                reachRight = true;
              }
            } else if(reachRight) {
              reachRight = false;
            }
          }
          y++;
          pixelPos += width * 4;
        }
      }
      ctx.putImageData(imgData, 0, 0);
    }

    // Helper: check if pixel at index matches given target rgba
    function matchColor(pixelPos, r, g, b, a, data) {
      return (data[pixelPos] === r &&
              data[pixelPos+1] === g &&
              data[pixelPos+2] === b &&
              data[pixelPos+3] === a);
    }

    // Canvas event listeners (handle both mouse and touch)
    canvas.addEventListener('mousedown', (e) => {
      if (currentTool === 'pen') {
        startDrawing(e);
      } else if (currentTool === 'bucket') {
        const pos = getPos(e);
        floodFill(Math.floor(pos.x), Math.floor(pos.y), colorPicker.value);
      }
    });
    canvas.addEventListener('mousemove', draw);
    canvas.addEventListener('mouseup', stopDrawing);
    canvas.addEventListener('mouseout', stopDrawing);

    // Touch support
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (currentTool === 'pen') {
        startDrawing(e);
      } else if (currentTool === 'bucket') {
        const pos = getPos(e);
        floodFill(Math.floor(pos.x), Math.floor(pos.y), colorPicker.value);
      }
    });
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      draw(e);
    });
    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      stopDrawing();
    });

    // Function to add the current canvas as a new frame
    addFrameBtn.addEventListener('click', () => {
      // Save current frame data
      const dataURL = canvas.toDataURL();
      frames.push(dataURL);
      currentFrameIndex = frames.length - 1;
      updateFramesPanel();
      // Clear canvas for next frame
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // Update the frames thumbnails display
    function updateFramesPanel() {
      framesPanel.innerHTML = '';
      frames.forEach((frame, idx) => {
        const img = document.createElement('img');
        img.src = frame;
        if (idx === currentFrameIndex) {
          img.classList.add('active-frame');
        }
        img.addEventListener('click', () => {
          // Load selected frame into canvas
          currentFrameIndex = idx;
          let tempImg = new Image();
          tempImg.onload = function() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
          }
          tempImg.src = frame;
          updateFramesPanel();
        });
        framesPanel.appendChild(img);
      });
    }

    // Preview animation: cycle through frames
    previewAnimBtn.addEventListener('click', () => {
      if (frames.length === 0) {
        alert("No frames to preview. Please add frames first.");
        return;
      }
      let i = 0;
      // Stop any existing preview interval
      if (previewInterval) {
        clearInterval(previewInterval);
        previewInterval = null;
      }
      previewInterval = setInterval(() => {
        let tempImg = new Image();
        tempImg.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
        }
        tempImg.src = frames[i];
        i = (i + 1) % frames.length;
      }, 300); // change frame every 300 ms
      // Stop preview after 5 seconds (optional)
      setTimeout(() => {
        clearInterval(previewInterval);
        previewInterval = null;
        // Reload the current frame into canvas
        if(currentFrameIndex >= 0) {
          let tempImg = new Image();
          tempImg.onload = function() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
          }
          tempImg.src = frames[currentFrameIndex];
        }
      }, 5000);
    });

    // Download MP4: This function plays back the frames on the canvas while recording using
    // the MediaRecorder API. It then downloads the recorded video. Note that due to browser limitations,
    // the resulting file might actually be in WebM format even though it is saved with an .mp4 extension.
    downloadMP4Btn.addEventListener('click', () => {
      if (frames.length === 0) {
        alert("No frames to record. Please add frames first.");
        return;
      }
      const fps = 30; // frames per second for the recorded video
      // Capture the canvas stream
      const stream = canvas.captureStream(fps);
      let options = { mimeType: 'video/mp4' };
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        // Fallback to WebM if mp4 is not supported
        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
          options.mimeType = 'video/webm;codecs=vp9';
        } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
          options.mimeType = 'video/webm;codecs=vp8';
        } else {
          alert("Your browser does not support the necessary recording format.");
          return;
        }
      }
      let recordedChunks = [];
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = function() {
        const blob = new Blob(recordedChunks, { type: options.mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        // Despite the potential format mismatch, we use .mp4 as per the instructions.
        a.href = url;
        a.download = "animation.mp4";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };

      // Start recording
      mediaRecorder.start();

      // Play the animation once while recording
      let i = 0;
      const frameDelay = 300; // delay per frame in ms (same as preview)
      function playFrame() {
        if (i >= frames.length) {
          mediaRecorder.stop();
          // After recording, restore the most recent frame on the canvas.
          if (currentFrameIndex >= 0) {
            const tempImg = new Image();
            tempImg.onload = function() {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
            };
            tempImg.src = frames[currentFrameIndex];
          }
          return;
        }
        const tempImg = new Image();
        tempImg.onload = function() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
          setTimeout(() => {
            i++;
            playFrame();
          }, frameDelay);
        };
        tempImg.src = frames[i];
      }
      playFrame();
    });
  </script>
</body>
</html>


