<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>Animation Creator</title>
  <link rel="manifest" href="manifest.json">
  <style>
    body {
      background: #f0f2f5;
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    #toolbar {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      width: 100%;
      max-width: 800px;
    }
    .tool-group {
      display: flex;
      align-items: center;
      gap: 5px;
      flex-wrap: wrap;
    }
    button {
      background: #007bff;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
      white-space: nowrap;
    }
    button:hover { background: #0056b3; }
    button.active { background: #0056b3; }
    input[type="color"],
    input[type="number"] {
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    label { font-size: 14px; color: #333; }
    #main {
      width: 100%;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #canvas {
      border: 2px solid #ccc;
      border-radius: 8px;
      background: #fff;
      touch-action: none;
      width: 100%;
      max-width: 800px;
    }
    #framesPanel {
      margin-top: 10px;
      display: flex;
      flex-wrap: nowrap;
      gap: 5px;
      overflow-x: auto;
      width: 100%;
      max-width: 800px;
    }
    #framesPanel img {
      width: 80px;
      height: auto;
      border: 2px solid transparent;
      cursor: move;
      border-radius: 4px;
    }
    #framesPanel img.active-frame { border-color: #007bff; }
    @media (max-width: 480px) {
      #toolbar {
        flex-direction: column;
        align-items: stretch;
        gap: 5px;
      }
      .tool-group { justify-content: space-around; }
      button { flex: 1 1 auto; font-size: 12px; padding: 6px 8px; }
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <div class="tool-group">
      <button id="penTool" class="active">Pen</button>
      <button id="eraserTool">Eraser</button>
      <button id="bucketTool">Bucket</button>
      <button id="selectTool">Select</button>
      <button id="copySelection">Copy</button>
      <button id="pasteTool">Paste</button>
      <button id="undoBtn">Undo</button>
    </div>
    <div class="tool-group">
      <input type="color" id="colorPicker" value="#000000">
      <button id="importImageBtn">Import Image</button>
      <input type="file" id="importImage" accept="image/*" style="display: none;">
    </div>
    <div class="tool-group">
      <button id="addFrame">Add Frame</button>
      <button id="deleteFrame">Delete Frame</button>
      <label for="frameRateInput">FPS:</label>
      <input type="number" id="frameRateInput" min="1" max="60" value="30">
      <button id="previewAnim">Preview</button>
      <button id="downloadMP4">Download MP4</button>
    </div>
    <div class="tool-group">
      <label for="bgColorPicker">Bg Color:</label>
      <input type="color" id="bgColorPicker" value="#ffffff">
      <button id="uploadBgBtn">Upload BG</button>
      <input type="file" id="uploadBg" accept="image/*" style="display: none;">
    </div>
    <div class="tool-group">
      <button id="saveProject">Save</button>
      <button id="loadProject">Load</button>
      <input type="file" id="loadProjectInput" accept=".json" style="display: none;">
    </div>
  </div>

  <div id="main">
    <canvas id="canvas" width="800" height="500"></canvas>
    <div id="framesPanel"></div>
  </div>

  <script>
    // ====== References ======
    const canvas = document.getElementById('canvas'),
          ctx = canvas.getContext('2d'),
          penTool = document.getElementById('penTool'),
          eraserTool = document.getElementById('eraserTool'),
          bucketTool = document.getElementById('bucketTool'),
          selectTool = document.getElementById('selectTool'),
          copyBtn = document.getElementById('copySelection'),
          pasteTool = document.getElementById('pasteTool'),
          undoBtn = document.getElementById('undoBtn'),
          colorPicker = document.getElementById('colorPicker'),
          importBtn = document.getElementById('importImageBtn'),
          importInput = document.getElementById('importImage'),
          addFrameBtn = document.getElementById('addFrame'),
          deleteFrameBtn = document.getElementById('deleteFrame'),
          frameRateInput = document.getElementById('frameRateInput'),
          previewBtn = document.getElementById('previewAnim'),
          downloadBtn = document.getElementById('downloadMP4'),
          bgColorPicker = document.getElementById('bgColorPicker'),
          uploadBgBtn = document.getElementById('uploadBgBtn'),
          uploadBgInput = document.getElementById('uploadBg'),
          saveBtn = document.getElementById('saveProject'),
          loadBtn = document.getElementById('loadProject'),
          loadInput = document.getElementById('loadProjectInput'),
          framesPanel = document.getElementById('framesPanel');

    // ====== State ======
    let currentTool='pen', drawing=false, lastX=0, lastY=0,
        frames=[], currentFrameIndex=-1, previewInterval=null,
        lastFrameData=null,
        isSelecting=false, isSelectionActive=false, selectionStart=null,
        selectionRect=null, savedSelectionImage=null,
        isMovingSelection=false, moveOffset={}, movePos=null,
        isResizing=false, currentResizeHandle=null,
        originalSelectionRect=null, originalSelectionImage=null,
        handleSize=10,
        background={color:'#ffffff',image:null},
        undoStack=[],
        draggedIndex=null,
        clipboard=null;

    // ====== Offscreen Drawing ======
    const offscreenCanvas = document.createElement('canvas');
    offscreenCanvas.width = canvas.width;
    offscreenCanvas.height = canvas.height;
    const offctx = offscreenCanvas.getContext('2d');

    // ====== Helpers ======
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      let cx, cy;
      if (e.touches && e.touches[0]) {
        cx = e.touches[0].clientX;
        cy = e.touches[0].clientY;
      } else {
        cx = e.clientX;
        cy = e.clientY;
      }
      const scaleX = canvas.width / rect.width;
      const scaleY = canvas.height / rect.height;
      return { x: (cx - rect.left) * scaleX, y: (cy - rect.top) * scaleY };
    }
    function pushUndoState() {
      undoStack.push(offctx.getImageData(0,0,canvas.width,canvas.height));
    }
    function undo() {
      if (!undoStack.length) return;
      offctx.putImageData(undoStack.pop(),0,0);
      redrawMainCanvas();
    }

    // ====== Redraw Canvas ======
    function redrawMainCanvas() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      if (background.image) {
        let bgImg = new Image();
        bgImg.onload = () => {
          ctx.drawImage(bgImg,0,0,canvas.width,canvas.height);
          drawOverlay();
        };
        bgImg.src = background.image;
      } else {
        ctx.fillStyle = background.color;
        ctx.fillRect(0,0,canvas.width,canvas.height);
        drawOverlay();
      }
      function drawOverlay() {
        if (lastFrameData) {
          ctx.globalAlpha = 0.3;
          let shadowImg = new Image();
          shadowImg.onload = () => {
            ctx.drawImage(shadowImg,0,0,canvas.width,canvas.height);
            ctx.globalAlpha = 1.0;
            ctx.drawImage(offscreenCanvas,0,0);
          };
          shadowImg.src = lastFrameData;
        } else {
          ctx.drawImage(offscreenCanvas,0,0);
        }
      }
    }

    // ====== Tool Button State ======
    function updateToolButtons() {
      [penTool,eraserTool,bucketTool,selectTool,pasteTool].forEach(b=>b.classList.remove('active'));
      if(currentTool==='pen') penTool.classList.add('active');
      if(currentTool==='eraser') eraserTool.classList.add('active');
      if(currentTool==='bucket') bucketTool.classList.add('active');
      if(currentTool==='select') selectTool.classList.add('active');
      if(currentTool==='paste') pasteTool.classList.add('active');
    }
    [penTool,eraserTool,bucketTool,selectTool,pasteTool].forEach(btn=>{
      btn.onclick = () => { currentTool = btn.id.replace('Tool',''); updateToolButtons(); };
    });
    undoBtn.onclick = undo;

    // ====== Drawing ======
    function startDrawing(e) {
      if (!['pen','eraser'].includes(currentTool)) return;
      drawing = true;
      const p = getPos(e);
      lastX = p.x; lastY = p.y;
      if (currentTool==='eraser') {
        offctx.save();
        offctx.globalCompositeOperation='destination-out';
        offctx.lineWidth=10;
      } else {
        offctx.globalCompositeOperation='source-over';
        offctx.lineWidth=3;
        offctx.strokeStyle=colorPicker.value;
      }
    }
    function draw(e) {
      if (!drawing) return;
      const p = getPos(e);
      offctx.beginPath();
      offctx.moveTo(lastX,lastY);
      offctx.lineTo(p.x,p.y);
      offctx.stroke();
      lastX = p.x; lastY = p.y;
      redrawMainCanvas();
    }
    function stopDrawing() {
      if (currentTool==='eraser') offctx.restore();
      drawing=false;
    }

    // ====== Bucket Fill ======
    function floodFillOffscreen(x,y,fillColor) {
      let img = offctx.getImageData(0,0,canvas.width,canvas.height),
          d = img.data, w=canvas.width, h=canvas.height;
      const hex=fillColor.replace('#',''),
            rF=parseInt(hex.substr(0,2),16),
            gF=parseInt(hex.substr(2,2),16),
            bF=parseInt(hex.substr(4,2),16),
            aF=255;
      let stack=[[x,y]], idx=(y*w+x)*4,
          rT=d[idx],gT=d[idx+1],bT=d[idx+2],aT=d[idx+3];
      if(rT===rF&&gT===gF&&bT===bF&&aT===aF) return;
      function match(i){return d[i]===rT&&d[i+1]===gT&&d[i+2]===bT&&d[i+3]===aT;}
      while(stack.length){
        let [cx,cy]=stack.pop(),
            pos=(cy*w+cx)*4;
        while(cy>=0&&match(pos)){cy--;pos-=w*4;}
        cy++;pos+=w*4;
        let reachL=false,reachR=false;
        while(cy<h&&match(pos)){
          d[pos]=rF;d[pos+1]=gF;d[pos+2]=bF;d[pos+3]=aF;
          if(cx>0){
            if(match(pos-4)){if(!reachL){stack.push([cx-1,cy]);reachL=true;}}
            else reachL=false;
          }
          if(cx<w-1){
            if(match(pos+4)){if(!reachR){stack.push([cx+1,cy]);reachR=true;}}
            else reachR=false;
          }
          cy++;pos+=w*4;
        }
      }
      offctx.putImageData(img,0,0);
    }

    // ====== Selection & Resize ======
    function getHandleAt(p){
      if(!selectionRect) return null;
      const {x,y,width,height} = selectionRect;
      if(Math.abs(p.x-x)<handleSize&&Math.abs(p.y-y)<handleSize) return 'tl';
      if(Math.abs(p.x-(x+width))<handleSize&&Math.abs(p.y-y)<handleSize) return 'tr';
      if(Math.abs(p.x-x)<handleSize&&Math.abs(p.y-(y+height))<handleSize) return 'bl';
      if(Math.abs(p.x-(x+width))<handleSize&&Math.abs(p.y-(y+height))<handleSize) return 'br';
      return null;
    }
    function handleSelectionStart(p){
      if(isSelectionActive){
        const h=getHandleAt(p);
        if(h){ isResizing=true; currentResizeHandle=h;
          originalSelectionRect={...selectionRect};
          originalSelectionImage=savedSelectionImage;
          return;
        }
      }
      if(isSelectionActive &&
         p.x>=selectionRect.x&&p.x<=selectionRect.x+selectionRect.width &&
         p.y>=selectionRect.y&&p.y<=selectionRect.y+selectionRect.height){
        isMovingSelection=true;
        moveOffset={x:p.x-selectionRect.x,y:p.y-selectionRect.y};
        movePos={x:selectionRect.x,y:selectionRect.y};
        return;
      }
      isSelecting=true;
      selectionStart=p;
      selectionRect={x:p.x,y:p.y,width:0,height:0};
      savedSelectionImage = offctx.getImageData(0,0,canvas.width,canvas.height);
      isSelectionActive=false;
    }
    function updateSelectionRect(p){
      if(isResizing){
        let r=originalSelectionRect;
        switch(currentResizeHandle){
          case 'tl':
            selectionRect.x=p.x; selectionRect.y=p.y;
            selectionRect.width=(r.x+r.width)-p.x;
            selectionRect.height=(r.y+r.height)-p.y;
            break;
          case 'tr':
            selectionRect.y=p.y;
            selectionRect.width=p.x-r.x;
            selectionRect.height=(r.y+r.height)-p.y;
            break;
          case 'bl':
            selectionRect.x=p.x;
            selectionRect.width=(r.x+r.width)-p.x;
            selectionRect.height=p.y-r.y;
            break;
          case 'br':
            selectionRect.width=p.x-r.x;
            selectionRect.height=p.y-r.y;
            break;
        }
      } else {
        selectionRect.x=Math.min(selectionStart.x,p.x);
        selectionRect.y=Math.min(selectionStart.y,p.y);
        selectionRect.width=Math.abs(p.x-selectionStart.x);
        selectionRect.height=Math.abs(p.y-selectionStart.y);
      }
      redrawMainCanvas();
      ctx.save(); ctx.setLineDash([5,3]); ctx.strokeStyle='red';
      ctx.strokeRect(selectionRect.x,selectionRect.y,selectionRect.width,selectionRect.height);
      ctx.restore();
    }
    function finalizeSelection(){
      if(selectionRect.width>0&&selectionRect.height>0){
        savedSelectionImage = offctx.getImageData(selectionRect.x,selectionRect.y,selectionRect.width,selectionRect.height);
        isSelectionActive=true;
      }
      redrawMainCanvas();
      ctx.save(); ctx.setLineDash([5,3]); ctx.strokeStyle='red';
      ctx.strokeRect(selectionRect.x,selectionRect.y,selectionRect.width,selectionRect.height);
      ctx.restore();
    }
    function commitMove(){
      pushUndoState();
      offctx.clearRect(selectionRect.x,selectionRect.y,selectionRect.width,selectionRect.height);
      offctx.putImageData(savedSelectionImage,movePos.x,movePos.y);
      selectionRect.x=movePos.x; selectionRect.y=movePos.y;
      isMovingSelection=false; isSelectionActive=false;
      redrawMainCanvas();
    }
    function commitResize(){
      createImageBitmap(originalSelectionImage).then(bitmap=>{
        let tmp=document.createElement('canvas');
        tmp.width=selectionRect.width; tmp.height=selectionRect.height;
        let tctx=tmp.getContext('2d');
        tctx.drawImage(bitmap,0,0,selectionRect.width,selectionRect.height);
        savedSelectionImage=tctx.getImageData(0,0,selectionRect.width,selectionRect.height);
        pushUndoState();
        offctx.clearRect(originalSelectionRect.x,originalSelectionRect.y,originalSelectionRect.width,originalSelectionRect.height);
        offctx.putImageData(savedSelectionImage,selectionRect.x,selectionRect.y);
        redrawMainCanvas();
      });
    }

    // ====== Copy & Paste ======
    copyBtn.onclick=()=>{
      if(isSelectionActive){ clipboard=savedSelectionImage; alert('Copied'); }
      else alert('No selection');
    };
    function pasteAt(e){
      if(!clipboard){ alert('Clipboard empty'); return; }
      pushUndoState();
      let p=getPos(e);
      offctx.putImageData(clipboard,p.x,p.y);
      redrawMainCanvas();
      currentTool='pen'; updateToolButtons();
    }

    // ====== Canvas Events ======
    function handleCanvasStart(e){
      e.preventDefault();
      let p=getPos(e);
      if(currentTool==='select') handleSelectionStart(p);
      else if(['pen','eraser'].includes(currentTool)){ pushUndoState(); startDrawing(e); }
      else if(currentTool==='bucket'){ pushUndoState(); floodFillOffscreen(Math.floor(p.x),Math.floor(p.y),colorPicker.value); redrawMainCanvas(); }
      else if(currentTool==='paste') pasteAt(e);
    }
    function handleCanvasMove(e){
      e.preventDefault();
      if((currentTool==='pen'||currentTool==='eraser')&&drawing) draw(e);
      else if(currentTool==='select'){
        if(isResizing||isSelecting) updateSelectionRect(getPos(e));
        else if(isMovingSelection){
          let p=getPos(e);
          movePos={x:p.x-moveOffset.x,y:p.y-moveOffset.y};
          redrawMainCanvas();
          ctx.putImageData(savedSelectionImage,movePos.x,movePos.y);
          ctx.save();ctx.setLineDash([5,3]);ctx.strokeStyle='red';
          ctx.strokeRect(movePos.x,movePos.y,selectionRect.width,selectionRect.height);
          ctx.restore();
        }
      }
    }
    function handleCanvasEnd(e){
      e.preventDefault();
      if(['pen','eraser'].includes(currentTool)) stopDrawing();
      else if(currentTool==='select'){
        if(isResizing){ isResizing=false; commitResize(); }
        else if(isSelecting){ isSelecting=false; finalizeSelection(); }
        else if(isMovingSelection) commitMove();
      }
    }
    canvas.addEventListener('mousedown',handleCanvasStart);
    canvas.addEventListener('mousemove',handleCanvasMove);
    canvas.addEventListener('mouseup',handleCanvasEnd);
    canvas.addEventListener('mouseout',e=>{ if((currentTool==='pen'||currentTool==='eraser')&&drawing) stopDrawing(); });
    canvas.addEventListener('touchstart',handleCanvasStart);
    canvas.addEventListener('touchmove',handleCanvasMove);
    canvas.addEventListener('touchend',handleCanvasEnd);

    // ====== Frame Management & Drag-Reorder ======
    function updateFramesPanel(){
      framesPanel.innerHTML='';
      frames.forEach((f,i)=>{
        const img=document.createElement('img');
        img.src=f; img.draggable=true; img.dataset.index=i;
        if(i===currentFrameIndex) img.classList.add('active-frame');
        img.addEventListener('dragstart',()=>{ draggedIndex=i; });
        img.addEventListener('dragover',e=>e.preventDefault());
        img.addEventListener('drop',e=>{
          e.preventDefault();
          let t=Number(e.target.dataset.index);
          if(draggedIndex===null||t===draggedIndex)return;
          let mv=frames.splice(draggedIndex,1)[0];
          frames.splice(t,0,mv);
          currentFrameIndex=t;
          updateFramesPanel();
        });
        img.addEventListener('click',()=>{
          loadFrame(i);
          updateFramesPanel();
        });
        framesPanel.appendChild(img);
      });
    }
    addFrameBtn.onclick=()=>{
      const tmp=document.createElement('canvas');
      tmp.width=canvas.width; tmp.height=canvas.height;
      const tctx=tmp.getContext('2d');
      if(background.image){
        let bg=new Image();
        bg.onload=()=>{
          tctx.drawImage(bg,0,0,canvas.width,canvas.height);
          tctx.drawImage(offscreenCanvas,0,0);
          const d=tmp.toDataURL();
          frames.push(d);
          currentFrameIndex=frames.length-1;
          lastFrameData=d;
          updateFramesPanel();
          offctx.clearRect(0,0,canvas.width,canvas.height);
          undoStack.length=0;
          redrawMainCanvas();
        };
        bg.src=background.image;
      } else {
        tctx.fillStyle=background.color;
        tctx.fillRect(0,0,canvas.width,canvas.height);
        tctx.drawImage(offscreenCanvas,0,0);
        const d=tmp.toDataURL();
        frames.push(d);
        currentFrameIndex=frames.length-1;
        lastFrameData=d;
        updateFramesPanel();
        offctx.clearRect(0,0,canvas.width,canvas.height);
        undoStack.length=0;
        redrawMainCanvas();
      }
    };
    deleteFrameBtn.onclick=()=>{
      if(currentFrameIndex<0){ alert("No frame to delete."); return; }
      frames.splice(currentFrameIndex,1);
      if(!frames.length){
        currentFrameIndex=-1; lastFrameData=null;
        offctx.clearRect(0,0,canvas.width,canvas.height);
        redrawMainCanvas();
      } else {
        currentFrameIndex=Math.max(0,currentFrameIndex-1);
        loadFrame(currentFrameIndex);
      }
      updateFramesPanel();
    };
    function loadFrame(i){
      currentFrameIndex=i;
      let img=new Image();
      img.onload=()=>{
        offctx.clearRect(0,0,canvas.width,canvas.height);
        offctx.drawImage(img,0,0,canvas.width,canvas.height);
        redrawMainCanvas();
        lastFrameData=frames[i];
        undoStack.length=0;
      };
      img.src=frames[i];
    }

    // ====== Preview & Export, Background, Save/Load, Service Worker ======
    // (Use exactly the same code from previous version for those parts.)

    // ====== Initialize & SW ======
    offctx.clearRect(0,0,canvas.width,canvas.height);
    redrawMainCanvas();
    if('serviceWorker' in navigator){
      window.addEventListener('load',()=>{
        navigator.serviceWorker.register('service-worker.js')
          .catch(console.error);
      });
    }
  </script>
</body>
</html>
    
