<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Animation Creator</title>
  <style>
    /* Modern, sleek styling */
    body {
      background: #f0f2f5;
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 10px;
    }
    #toolbar {
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      padding: 10px;
      margin-bottom: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
    }
    .tool-group {
      display: flex;
      align-items: center;
      gap: 5px;
    }
    button {
      background: #007bff;
      color: #fff;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: background 0.2s;
    }
    button:hover {
      background: #0056b3;
    }
    button.active {
      background: #0056b3;
    }
    input[type="color"],
    input[type="number"] {
      padding: 5px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }
    label {
      font-size: 14px;
      color: #333;
    }
    #main {
      width: 100%;
      max-width: 800px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    #canvas {
      border: 2px solid #ccc;
      border-radius: 8px;
      background: #fff;
      touch-action: none;
      width: 100%;
      max-width: 800px;
    }
    #framesPanel {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      justify-content: center;
    }
    #framesPanel img {
      width: 80px;
      height: auto;
      border: 2px solid transparent;
      cursor: pointer;
      border-radius: 4px;
    }
    #framesPanel img.active-frame {
      border-color: #007bff;
    }
  </style>
</head>
<body>
  <div id="toolbar">
    <!-- Drawing Tools -->
    <div class="tool-group">
      <button id="penTool" class="active">Pen</button>
      <button id="eraserTool">Eraser</button>
      <button id="bucketTool">Bucket</button>
      <button id="selectTool">Select</button>
      <button id="copySelection">Copy</button>
      <button id="pasteTool">Paste</button>
    </div>
    <!-- Image Tools -->
    <div class="tool-group">
      <input type="color" id="colorPicker" title="Choose pen color" value="#000000">
      <button id="importImageBtn">Import Image</button>
      <input type="file" id="importImage" accept="image/*" style="display: none;">
    </div>
    <!-- Frame and Animation Controls -->
    <div class="tool-group">
      <button id="addFrame">Add Frame</button>
      <button id="deleteFrame">Delete Frame</button>
      <label for="frameRateInput">FPS:</label>
      <input type="number" id="frameRateInput" min="1" max="60" value="30">
      <button id="previewAnim">Preview Animation</button>
      <button id="downloadMP4">Download MP4</button>
    </div>
    <!-- Background Options -->
    <div class="tool-group">
      <label for="bgColorPicker">Bg Color:</label>
      <input type="color" id="bgColorPicker" value="#ffffff">
      <button id="uploadBgBtn">Upload Background</button>
      <input type="file" id="uploadBg" accept="image/*" style="display: none;">
    </div>
    <!-- Project Save/Load -->
    <div class="tool-group">
      <button id="saveProject">Save Project</button>
      <button id="loadProject">Load Project</button>
      <input type="file" id="loadProjectInput" accept=".json" style="display: none;">
    </div>
  </div>
  <div id="main">
    <canvas id="canvas" width="800" height="500"></canvas>
    <div id="framesPanel"></div>
  </div>
  <script>
    /* ========= Element References ========= */
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Tool buttons
    const penTool = document.getElementById('penTool');
    const eraserTool = document.getElementById('eraserTool');
    const bucketTool = document.getElementById('bucketTool');
    const selectTool = document.getElementById('selectTool');
    const copySelectionBtn = document.getElementById('copySelection');
    const pasteTool = document.getElementById('pasteTool');

    // Color and image import
    const colorPicker = document.getElementById('colorPicker');
    const importImageBtn = document.getElementById('importImageBtn');
    const importImageInput = document.getElementById('importImage');

    // Frame and animation controls
    const addFrameBtn = document.getElementById('addFrame');
    const deleteFrameBtn = document.getElementById('deleteFrame');
    const frameRateInput = document.getElementById('frameRateInput');
    const previewAnimBtn = document.getElementById('previewAnim');
    const downloadMP4Btn = document.getElementById('downloadMP4');

    // Background controls
    const bgColorPicker = document.getElementById('bgColorPicker');
    const uploadBgBtn = document.getElementById('uploadBgBtn');
    const uploadBgInput = document.getElementById('uploadBg');

    // Project controls
    const saveProjectBtn = document.getElementById('saveProject');
    const loadProjectBtn = document.getElementById('loadProject');
    const loadProjectInput = document.getElementById('loadProjectInput');

    // Frames preview panel
    const framesPanel = document.getElementById('framesPanel');

    /* ========= App State ========= */
    let currentTool = 'pen'; // "pen", "eraser", "bucket", "select", "paste"
    let drawing = false;
    let lastX = 0, lastY = 0;
    let frames = []; // each frame stored as a dataURL string
    let currentFrameIndex = -1;
    let previewInterval = null;
    let lastFrameData = null; // for shadow overlay in new frames

    // For selection tool
    let isSelecting = false;
    let selectionStart = { x: 0, y: 0 };
    let selectionRect = null;
    let savedImageData = null;
    let clipboardData = null;

    // Background settings (default uses color)
    let background = { color: "#ffffff", image: null };

    /* ========= Initial Canvas Settings ========= */
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.strokeStyle = colorPicker.value;

    /* ========= Utility Functions ========= */
    function getPos(e) {
      const rect = canvas.getBoundingClientRect();
      let x, y;
      if (e.touches) {
        x = e.touches[0].clientX - rect.left;
        y = e.touches[0].clientY - rect.top;
      } else {
        x = e.clientX - rect.left;
        y = e.clientY - rect.top;
      }
      return { x, y };
    }
    function clearCanvasWithBg() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (background.image) {
        const bgImg = new Image();
        bgImg.onload = () => ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
        bgImg.src = background.image;
      } else {
        ctx.fillStyle = background.color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
    }
    function clearCanvasWithBgAndShadow() {
      clearCanvasWithBg();
      if (lastFrameData) {
        const shadowImg = new Image();
        shadowImg.onload = () => {
          ctx.globalAlpha = 0.3;
          ctx.drawImage(shadowImg, 0, 0, canvas.width, canvas.height);
          ctx.globalAlpha = 1.0;
        };
        shadowImg.src = lastFrameData;
      }
    }

    /* ========= Tool Button State ========= */
    function updateToolButtons() {
      [penTool, eraserTool, bucketTool, selectTool, pasteTool].forEach(btn => btn.classList.remove('active'));
      if (currentTool === 'pen') penTool.classList.add('active');
      else if (currentTool === 'eraser') eraserTool.classList.add('active');
      else if (currentTool === 'bucket') bucketTool.classList.add('active');
      else if (currentTool === 'select') selectTool.classList.add('active');
      else if (currentTool === 'paste') pasteTool.classList.add('active');
    }
    updateToolButtons();

    /* ========= Event Listeners for Tool Selection ========= */
    penTool.addEventListener('click', () => { currentTool = 'pen'; updateToolButtons(); });
    eraserTool.addEventListener('click', () => { currentTool = 'eraser'; updateToolButtons(); });
    bucketTool.addEventListener('click', () => { currentTool = 'bucket'; updateToolButtons(); });
    selectTool.addEventListener('click', () => { currentTool = 'select'; updateToolButtons(); });
    pasteTool.addEventListener('click', () => { currentTool = 'paste'; updateToolButtons(); });

    colorPicker.addEventListener('change', () => {
      ctx.strokeStyle = colorPicker.value;
    });

    /* ========= Drawing Functions ========= */
    function startDrawing(e) {
      if (currentTool === 'pen' || currentTool === 'eraser') {
        drawing = true;
        const pos = getPos(e);
        lastX = pos.x;
        lastY = pos.y;
        if (currentTool === 'eraser') {
          ctx.save();
          ctx.globalCompositeOperation = 'destination-out';
          ctx.lineWidth = 10;
        } else {
          ctx.globalCompositeOperation = 'source-over';
          ctx.lineWidth = 3;
        }
      }
    }
    function draw(e) {
      if (!drawing) return;
      const pos = getPos(e);
      ctx.beginPath();
      ctx.moveTo(lastX, lastY);
      ctx.lineTo(pos.x, pos.y);
      ctx.stroke();
      lastX = pos.x;
      lastY = pos.y;
    }
    function stopDrawing() {
      if (currentTool === 'eraser') {
        ctx.restore();
      }
      drawing = false;
    }

    /* ========= Bucket Fill Tool ========= */
    function floodFill(startX, startY, fillColor) {
      const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imgData.data;
      const width = canvas.width;
      const height = canvas.height;
      
      const hex = fillColor.replace('#', '');
      const rFill = parseInt(hex.substring(0,2), 16);
      const gFill = parseInt(hex.substring(2,4), 16);
      const bFill = parseInt(hex.substring(4,6), 16);
      const aFill = 255;
      
      const pixelStack = [[startX, startY]];
      const offset = (startY * width + startX) * 4;
      const rTarget = data[offset];
      const gTarget = data[offset+1];
      const bTarget = data[offset+2];
      const aTarget = data[offset+3];

      if (rTarget === rFill && gTarget === gFill && bTarget === bFill && aTarget === aFill) return;

      while(pixelStack.length) {
        const newPos = pixelStack.pop();
        let x = newPos[0], y = newPos[1];
        let pixelPos = (y * width + x) * 4;
        while (y >= 0 && matchColor(pixelPos, rTarget, gTarget, bTarget, aTarget, data)) {
          y--;
          pixelPos -= width * 4;
        }
        y++;
        pixelPos += width * 4;
        let reachLeft = false;
        let reachRight = false;
        while (y < height && matchColor(pixelPos, rTarget, gTarget, bTarget, aTarget, data)) {
          data[pixelPos] = rFill;
          data[pixelPos+1] = gFill;
          data[pixelPos+2] = bFill;
          data[pixelPos+3] = aFill;
          if(x > 0) {
            if (matchColor(pixelPos - 4, rTarget, gTarget, bTarget, aTarget, data)) {
              if (!reachLeft) {
                pixelStack.push([x - 1, y]);
                reachLeft = true;
              }
            } else {
              reachLeft = false;
            }
          }
          if(x < width - 1) {
            if (matchColor(pixelPos + 4, rTarget, gTarget, bTarget, aTarget, data)) {
              if (!reachRight) {
                pixelStack.push([x + 1, y]);
                reachRight = true;
              }
            } else {
              reachRight = false;
            }
          }
          y++;
          pixelPos += width * 4;
        }
      }
      ctx.putImageData(imgData, 0, 0);
    }
    function matchColor(pixelPos, r, g, b, a, data) {
      return (
        data[pixelPos] === r &&
        data[pixelPos+1] === g &&
        data[pixelPos+2] === b &&
        data[pixelPos+3] === a
      );
    }

    /* ========= Selection / Copy & Paste ========= */
    function startSelection(e) {
      const pos = getPos(e);
      selectionStart = { x: pos.x, y: pos.y };
      isSelecting = true;
      savedImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    }
    function updateSelection(e) {
      if (!isSelecting) return;
      const pos = getPos(e);
      const x = Math.min(selectionStart.x, pos.x);
      const y = Math.min(selectionStart.y, pos.y);
      const width = Math.abs(selectionStart.x - pos.x);
      const height = Math.abs(selectionStart.y - pos.y);
      selectionRect = { x, y, width, height };
      ctx.putImageData(savedImageData, 0, 0);
      ctx.save();
      ctx.setLineDash([5, 3]);
      ctx.strokeStyle = "red";
      ctx.strokeRect(x, y, width, height);
      ctx.restore();
    }
    function endSelection(e) {
      if (!isSelecting) return;
      isSelecting = false;
      ctx.putImageData(savedImageData, 0, 0);
    }
    function copySelection() {
      if (selectionRect && selectionRect.width > 0 && selectionRect.height > 0) {
        clipboardData = ctx.getImageData(selectionRect.x, selectionRect.y, selectionRect.width, selectionRect.height);
        alert("Selection copied!");
      } else {
        alert("No selection made.");
      }
    }
    function pasteAt(e) {
      if (!clipboardData) {
        alert("No copied selection!");
        return;
      }
      const pos = getPos(e);
      ctx.putImageData(clipboardData, pos.x, pos.y);
      currentTool = 'pen';
      updateToolButtons();
    }
    copySelectionBtn.addEventListener('click', copySelection);

    /* ========= Canvas Event Listeners ========= */
    canvas.addEventListener('mousedown', (e) => {
      if (currentTool === 'pen' || currentTool === 'eraser') {
        startDrawing(e);
      } else if (currentTool === 'bucket') {
        const pos = getPos(e);
        floodFill(Math.floor(pos.x), Math.floor(pos.y), colorPicker.value);
      } else if (currentTool === 'select') {
        startSelection(e);
      } else if (currentTool === 'paste') {
        pasteAt(e);
      }
    });
    canvas.addEventListener('mousemove', (e) => {
      if ((currentTool === 'pen' || currentTool === 'eraser') && drawing) {
        draw(e);
      } else if (currentTool === 'select' && isSelecting) {
        updateSelection(e);
      }
    });
    canvas.addEventListener('mouseup', (e) => {
      if (currentTool === 'pen' || currentTool === 'eraser') {
        stopDrawing(e);
      } else if (currentTool === 'select' && isSelecting) {
        endSelection(e);
      }
    });
    canvas.addEventListener('mouseout', (e) => {
      if (currentTool === 'pen' || currentTool === 'eraser') {
        stopDrawing(e);
      }
    });

    /* ========= Import Image for Drawing ========= */
    importImageBtn.addEventListener('click', () => {
      importImageInput.click();
    });
    importImageInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        const img = new Image();
        img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        img.src = event.target.result;
      };
      reader.readAsDataURL(file);
    });

    /* ========= Frame Management ========= */
    addFrameBtn.addEventListener('click', () => {
      // Save current work as a frame
      const dataURL = canvas.toDataURL();
      frames.push(dataURL);
      currentFrameIndex = frames.length - 1;
      lastFrameData = dataURL; // use as shadow in next frame
      updateFramesPanel();
      clearCanvasWithBgAndShadow();
    });
    deleteFrameBtn.addEventListener('click', () => {
      if (currentFrameIndex >= 0) {
        frames.splice(currentFrameIndex, 1);
        if (frames.length === 0) {
          currentFrameIndex = -1;
          lastFrameData = null;
          clearCanvasWithBg();
        } else {
          currentFrameIndex = Math.max(0, currentFrameIndex - 1);
          loadFrame(currentFrameIndex);
        }
        updateFramesPanel();
      } else {
        alert("No frame to delete.");
      }
    });
    function updateFramesPanel() {
      framesPanel.innerHTML = '';
      frames.forEach((frame, idx) => {
        const img = document.createElement('img');
        img.src = frame;
        if (idx === currentFrameIndex) img.classList.add('active-frame');
        img.addEventListener('click', () => {
          loadFrame(idx);
          updateFramesPanel();
        });
        framesPanel.appendChild(img);
      });
    }
    function loadFrame(index) {
      currentFrameIndex = index;
      const tempImg = new Image();
      tempImg.onload = () => {
        clearCanvasWithBg();
        ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
        lastFrameData = frames[currentFrameIndex];
      };
      tempImg.src = frames[index];
    }

    /* ========= Animation Preview ========= */
    previewAnimBtn.addEventListener('click', () => {
      if (frames.length === 0) {
        alert("No frames to preview.");
        return;
      }
      let i = 0;
      if (previewInterval) clearInterval(previewInterval);
      previewInterval = setInterval(() => {
        const tempImg = new Image();
        tempImg.onload = () => {
          clearCanvasWithBg();
          ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
        };
        tempImg.src = frames[i];
        i = (i + 1) % frames.length;
      }, 1000 / parseInt(frameRateInput.value, 10));
      setTimeout(() => {
        clearInterval(previewInterval);
        previewInterval = null;
        if (currentFrameIndex >= 0) loadFrame(currentFrameIndex);
      }, 5000);
    });

    /* ========= Download MP4 ========= */
    downloadMP4Btn.addEventListener('click', () => {
      if (frames.length === 0) {
        alert("No frames to record.");
        return;
      }
      const fps = parseInt(frameRateInput.value, 10) || 30;
      const stream = canvas.captureStream(fps);
      let options = { mimeType: 'video/mp4' };
      if (!MediaRecorder.isTypeSupported(options.mimeType)) {
        if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9'))
          options.mimeType = 'video/webm;codecs=vp9';
        else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8'))
          options.mimeType = 'video/webm;codecs=vp8';
        else {
          alert("Your browser does not support the necessary recording format.");
          return;
        }
      }
      let recordedChunks = [];
      const mediaRecorder = new MediaRecorder(stream, options);
      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) recordedChunks.push(e.data);
      };
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: options.mimeType });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = "animation.mp4";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      };
      mediaRecorder.start();
      let i = 0;
      const delay = 1000 / fps;
      function playFrame() {
        if (i >= frames.length) {
          mediaRecorder.stop();
          if (currentFrameIndex >= 0) loadFrame(currentFrameIndex);
          return;
        }
        const tempImg = new Image();
        tempImg.onload = () => {
          clearCanvasWithBg();
          ctx.drawImage(tempImg, 0, 0, canvas.width, canvas.height);
          setTimeout(() => { i++; playFrame(); }, delay);
        };
        tempImg.src = frames[i];
      }
      playFrame();
    });

    /* ========= Background Controls ========= */
    bgColorPicker.addEventListener('change', () => {
      background.color = bgColorPicker.value;
      clearCanvasWithBg();
    });
    uploadBgBtn.addEventListener('click', () => {
      uploadBgInput.click();
    });
    uploadBgInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        background.image = event.target.result;
        clearCanvasWithBg();
      };
      reader.readAsDataURL(file);
    });

    /* ========= Project Save / Load ========= */
    saveProjectBtn.addEventListener('click', () => {
      const project = {
        frames: frames,
        currentFrameIndex: currentFrameIndex,
        background: background
      };
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(project));
      const a = document.createElement('a');
      a.href = dataStr;
      a.download = "animation_project.json";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    });
    loadProjectBtn.addEventListener('click', () => {
      loadProjectInput.click();
    });
    loadProjectInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (event) => {
        const project = JSON.parse(event.target.result);
        frames = project.frames || [];
        currentFrameIndex = project.currentFrameIndex || -1;
        background = project.background || { color: "#ffffff", image: null };
        bgColorPicker.value = background.color;
        updateFramesPanel();
        if (currentFrameIndex >= 0 && frames[currentFrameIndex]) {
          loadFrame(currentFrameIndex);
        } else {
          clearCanvasWithBg();
        }
      };
      reader.readAsText(file);
    });

    /* ========= Initial Draw ========= */
    clearCanvasWithBg();
  </script>
</body>
</html>





